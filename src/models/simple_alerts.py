"""Simple rule-based alerts module for marketing metrics.

This module provides rule-based alerting for marketing performance metrics
including ROAS, CPA, revenue drops, and other key indicators.
"""

from __future__ import annotations

from dataclasses import dataclass, field
from datetime import datetime, timezone
from enum import Enum
from typing import Any


class AlertType(Enum):
    """Types of alerts that can be generated."""

    LOW_ROAS = "low_roas"
    HIGH_CPA = "high_cpa"
    REVENUE_DROP = "revenue_drop"
    SPEND_ANOMALY = "spend_anomaly"
    LOW_CONVERSION_RATE = "low_conversion_rate"
    HIGH_CANCELLATION_RATE = "high_cancellation_rate"
    BUDGET_EXHAUSTED = "budget_exhausted"
    CAMPAIGN_UNDERPERFORMING = "campaign_underperforming"


class AlertSeverity(Enum):
    """Severity levels for alerts."""

    INFO = "info"
    WARNING = "warning"
    CRITICAL = "critical"


class AlertStatus(Enum):
    """Status of an alert."""

    ACTIVE = "active"
    ACKNOWLEDGED = "acknowledged"
    RESOLVED = "resolved"


@dataclass
class AlertRule:
    """Definition of an alert rule.

    Attributes:
        name: Human-readable name of the rule.
        alert_type: Type of alert this rule generates.
        condition: Description of the condition that triggers the alert.
        threshold: Threshold value that triggers the alert.
        comparison: Comparison operator ('lt', 'gt', 'lte', 'gte', 'eq').
        severity: Severity level when triggered.
        enabled: Whether the rule is active.
        platforms: Platforms this rule applies to (empty = all).
    """

    name: str
    alert_type: AlertType
    condition: str
    threshold: float
    comparison: str = "lt"  # lt, gt, lte, gte, eq
    severity: AlertSeverity = AlertSeverity.WARNING
    enabled: bool = True
    platforms: list[str] = field(default_factory=list)

    def evaluate(self, value: float | None) -> bool:
        """Evaluate if the rule triggers for a given value.

        Args:
            value: The metric value to evaluate.

        Returns:
            True if the rule triggers (alert condition met).
        """
        if value is None:
            return False

        if self.comparison == "lt":
            return value < self.threshold
        elif self.comparison == "gt":
            return value > self.threshold
        elif self.comparison == "lte":
            return value <= self.threshold
        elif self.comparison == "gte":
            return value >= self.threshold
        elif self.comparison == "eq":
            return value == self.threshold
        return False

    def to_dict(self) -> dict[str, Any]:
        """Convert rule to dictionary."""
        return {
            "name": self.name,
            "alert_type": self.alert_type.value,
            "condition": self.condition,
            "threshold": self.threshold,
            "comparison": self.comparison,
            "severity": self.severity.value,
            "enabled": self.enabled,
            "platforms": self.platforms,
        }


@dataclass
class Alert:
    """An alert instance generated by a rule.

    Attributes:
        alert_id: Unique identifier for the alert.
        alert_type: Type of alert.
        severity: Severity level.
        title: Short title for the alert.
        message: Detailed message explaining the alert.
        metric_name: Name of the metric that triggered the alert.
        metric_value: Actual value of the metric.
        threshold: Threshold that was crossed.
        platform: Platform where the alert occurred.
        entity_type: Type of entity (campaign, shop, product, etc.).
        entity_id: ID of the entity.
        entity_name: Name of the entity.
        date: Date the alert applies to.
        created_at: When the alert was created.
        status: Current status of the alert.
        metadata: Additional context data.
    """

    alert_id: str
    alert_type: AlertType
    severity: AlertSeverity
    title: str
    message: str
    metric_name: str
    metric_value: float
    threshold: float
    platform: str
    entity_type: str
    entity_id: str
    entity_name: str
    date: datetime
    created_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
    status: AlertStatus = AlertStatus.ACTIVE
    metadata: dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> dict[str, Any]:
        """Convert alert to dictionary for storage."""
        return {
            "alert_id": self.alert_id,
            "alert_type": self.alert_type.value,
            "severity": self.severity.value,
            "title": self.title,
            "message": self.message,
            "metric_name": self.metric_name,
            "metric_value": self.metric_value,
            "threshold": self.threshold,
            "platform": self.platform,
            "entity_type": self.entity_type,
            "entity_id": self.entity_id,
            "entity_name": self.entity_name,
            "date": self.date.isoformat(),
            "created_at": self.created_at.isoformat(),
            "status": self.status.value,
            "metadata": self.metadata,
        }

    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> "Alert":
        """Create an Alert from a dictionary.

        Args:
            data: Dictionary with alert data.

        Returns:
            Alert instance.
        """
        return cls(
            alert_id=data["alert_id"],
            alert_type=AlertType(data["alert_type"]),
            severity=AlertSeverity(data["severity"]),
            title=data["title"],
            message=data["message"],
            metric_name=data["metric_name"],
            metric_value=data["metric_value"],
            threshold=data["threshold"],
            platform=data["platform"],
            entity_type=data["entity_type"],
            entity_id=data["entity_id"],
            entity_name=data["entity_name"],
            date=datetime.fromisoformat(data["date"]),
            created_at=datetime.fromisoformat(data["created_at"]),
            status=AlertStatus(data["status"]),
            metadata=data.get("metadata", {}),
        )


# Default alert rules for marketing metrics
DEFAULT_ALERT_RULES: list[AlertRule] = [
    # ROAS Rules
    AlertRule(
        name="Low ROAS - Critical",
        alert_type=AlertType.LOW_ROAS,
        condition="ROAS < 1.5",
        threshold=1.5,
        comparison="lt",
        severity=AlertSeverity.CRITICAL,
    ),
    AlertRule(
        name="Low ROAS - Warning",
        alert_type=AlertType.LOW_ROAS,
        condition="ROAS < 2.0",
        threshold=2.0,
        comparison="lt",
        severity=AlertSeverity.WARNING,
    ),
    # CPA Rules
    AlertRule(
        name="High CPA - Critical",
        alert_type=AlertType.HIGH_CPA,
        condition="CPA > 500 THB",
        threshold=500.0,
        comparison="gt",
        severity=AlertSeverity.CRITICAL,
    ),
    AlertRule(
        name="High CPA - Warning",
        alert_type=AlertType.HIGH_CPA,
        condition="CPA > 300 THB",
        threshold=300.0,
        comparison="gt",
        severity=AlertSeverity.WARNING,
    ),
    # Revenue Drop Rules
    AlertRule(
        name="Revenue Drop - Critical",
        alert_type=AlertType.REVENUE_DROP,
        condition="Revenue drop > 30% WoW",
        threshold=-0.30,
        comparison="lt",
        severity=AlertSeverity.CRITICAL,
    ),
    AlertRule(
        name="Revenue Drop - Warning",
        alert_type=AlertType.REVENUE_DROP,
        condition="Revenue drop > 20% WoW",
        threshold=-0.20,
        comparison="lt",
        severity=AlertSeverity.WARNING,
    ),
    # Conversion Rate Rules
    AlertRule(
        name="Low Conversion Rate",
        alert_type=AlertType.LOW_CONVERSION_RATE,
        condition="Conversion rate < 1%",
        threshold=0.01,
        comparison="lt",
        severity=AlertSeverity.WARNING,
    ),
    # Cancellation Rate Rules
    AlertRule(
        name="High Cancellation Rate",
        alert_type=AlertType.HIGH_CANCELLATION_RATE,
        condition="Cancellation rate > 15%",
        threshold=0.15,
        comparison="gt",
        severity=AlertSeverity.WARNING,
    ),
    # Spend Anomaly Rules
    AlertRule(
        name="Spend Spike",
        alert_type=AlertType.SPEND_ANOMALY,
        condition="Spend increase > 50% vs average",
        threshold=0.50,
        comparison="gt",
        severity=AlertSeverity.INFO,
    ),
    # Campaign Underperforming
    AlertRule(
        name="Campaign Underperforming",
        alert_type=AlertType.CAMPAIGN_UNDERPERFORMING,
        condition="ROAS < 50% of benchmark",
        threshold=0.50,
        comparison="lt",
        severity=AlertSeverity.WARNING,
    ),
]


class AlertRuleEngine:
    """Engine for evaluating alert rules against metric data.

    The engine maintains a set of rules and can evaluate incoming
    metric data to generate alerts when thresholds are crossed.
    """

    def __init__(self, rules: list[AlertRule] | None = None):
        """Initialize the alert rule engine.

        Args:
            rules: List of rules to use. Defaults to DEFAULT_ALERT_RULES.
        """
        self.rules = rules if rules is not None else DEFAULT_ALERT_RULES.copy()
        self._alert_counter = 0

    def add_rule(self, rule: AlertRule) -> None:
        """Add a new rule to the engine.

        Args:
            rule: The rule to add.
        """
        self.rules.append(rule)

    def remove_rule(self, rule_name: str) -> bool:
        """Remove a rule by name.

        Args:
            rule_name: Name of the rule to remove.

        Returns:
            True if rule was found and removed.
        """
        for i, rule in enumerate(self.rules):
            if rule.name == rule_name:
                self.rules.pop(i)
                return True
        return False

    def get_rules_by_type(self, alert_type: AlertType) -> list[AlertRule]:
        """Get all rules of a specific type.

        Args:
            alert_type: The type of alerts to filter by.

        Returns:
            List of matching rules.
        """
        return [r for r in self.rules if r.alert_type == alert_type and r.enabled]

    def _generate_alert_id(self) -> str:
        """Generate a unique alert ID."""
        self._alert_counter += 1
        timestamp = datetime.now(timezone.utc).strftime("%Y%m%d%H%M%S")
        return f"ALERT-{timestamp}-{self._alert_counter:04d}"

    def evaluate_roas(
        self,
        roas: float | None,
        platform: str,
        entity_type: str,
        entity_id: str,
        entity_name: str,
        date: datetime,
    ) -> list[Alert]:
        """Evaluate ROAS against rules and generate alerts.

        Args:
            roas: The ROAS value to evaluate.
            platform: Platform (shopee, lazada, etc.).
            entity_type: Type of entity (campaign, shop, daily, etc.).
            entity_id: Identifier of the entity.
            entity_name: Human-readable name.
            date: Date of the metric.

        Returns:
            List of alerts generated (may be empty).
        """
        alerts = []
        if roas is None:
            return alerts

        for rule in self.get_rules_by_type(AlertType.LOW_ROAS):
            if rule.platforms and platform not in rule.platforms:
                continue

            if rule.evaluate(roas):
                alerts.append(
                    Alert(
                        alert_id=self._generate_alert_id(),
                        alert_type=AlertType.LOW_ROAS,
                        severity=rule.severity,
                        title=f"Low ROAS: {entity_name}",
                        message=f"ROAS is {roas:.2f}, below threshold of {rule.threshold}",
                        metric_name="roas",
                        metric_value=roas,
                        threshold=rule.threshold,
                        platform=platform,
                        entity_type=entity_type,
                        entity_id=entity_id,
                        entity_name=entity_name,
                        date=date,
                        metadata={"rule_name": rule.name},
                    )
                )
                break  # Only trigger highest severity rule

        return alerts

    def evaluate_cpa(
        self,
        cpa: float | None,
        platform: str,
        entity_type: str,
        entity_id: str,
        entity_name: str,
        date: datetime,
    ) -> list[Alert]:
        """Evaluate CPA against rules and generate alerts.

        Args:
            cpa: The CPA value to evaluate.
            platform: Platform (shopee, lazada, etc.).
            entity_type: Type of entity.
            entity_id: Identifier of the entity.
            entity_name: Human-readable name.
            date: Date of the metric.

        Returns:
            List of alerts generated.
        """
        alerts = []
        if cpa is None:
            return alerts

        for rule in self.get_rules_by_type(AlertType.HIGH_CPA):
            if rule.platforms and platform not in rule.platforms:
                continue

            if rule.evaluate(cpa):
                alerts.append(
                    Alert(
                        alert_id=self._generate_alert_id(),
                        alert_type=AlertType.HIGH_CPA,
                        severity=rule.severity,
                        title=f"High CPA: {entity_name}",
                        message=f"CPA is {cpa:.2f} THB, above threshold of {rule.threshold} THB",
                        metric_name="cpa",
                        metric_value=cpa,
                        threshold=rule.threshold,
                        platform=platform,
                        entity_type=entity_type,
                        entity_id=entity_id,
                        entity_name=entity_name,
                        date=date,
                        metadata={"rule_name": rule.name},
                    )
                )
                break

        return alerts

    def evaluate_revenue_change(
        self,
        revenue_change_pct: float | None,
        platform: str,
        entity_type: str,
        entity_id: str,
        entity_name: str,
        date: datetime,
        current_revenue: float | None = None,
        previous_revenue: float | None = None,
    ) -> list[Alert]:
        """Evaluate revenue change against rules.

        Args:
            revenue_change_pct: Percentage change in revenue (e.g., -0.25 for -25%).
            platform: Platform.
            entity_type: Type of entity.
            entity_id: Entity ID.
            entity_name: Entity name.
            date: Date of the metric.
            current_revenue: Current period revenue.
            previous_revenue: Previous period revenue.

        Returns:
            List of alerts generated.
        """
        alerts = []
        if revenue_change_pct is None:
            return alerts

        for rule in self.get_rules_by_type(AlertType.REVENUE_DROP):
            if rule.platforms and platform not in rule.platforms:
                continue

            if rule.evaluate(revenue_change_pct):
                pct_str = f"{abs(revenue_change_pct) * 100:.1f}%"
                alerts.append(
                    Alert(
                        alert_id=self._generate_alert_id(),
                        alert_type=AlertType.REVENUE_DROP,
                        severity=rule.severity,
                        title=f"Revenue Drop: {entity_name}",
                        message=f"Revenue dropped by {pct_str} compared to previous period",
                        metric_name="revenue_change_pct",
                        metric_value=revenue_change_pct,
                        threshold=rule.threshold,
                        platform=platform,
                        entity_type=entity_type,
                        entity_id=entity_id,
                        entity_name=entity_name,
                        date=date,
                        metadata={
                            "rule_name": rule.name,
                            "current_revenue": current_revenue,
                            "previous_revenue": previous_revenue,
                        },
                    )
                )
                break

        return alerts

    def evaluate_conversion_rate(
        self,
        conversion_rate: float | None,
        platform: str,
        entity_type: str,
        entity_id: str,
        entity_name: str,
        date: datetime,
    ) -> list[Alert]:
        """Evaluate conversion rate against rules.

        Args:
            conversion_rate: Conversion rate (e.g., 0.02 for 2%).
            platform: Platform.
            entity_type: Type of entity.
            entity_id: Entity ID.
            entity_name: Entity name.
            date: Date of the metric.

        Returns:
            List of alerts generated.
        """
        alerts = []
        if conversion_rate is None:
            return alerts

        for rule in self.get_rules_by_type(AlertType.LOW_CONVERSION_RATE):
            if rule.platforms and platform not in rule.platforms:
                continue

            if rule.evaluate(conversion_rate):
                pct_str = f"{conversion_rate * 100:.2f}%"
                alerts.append(
                    Alert(
                        alert_id=self._generate_alert_id(),
                        alert_type=AlertType.LOW_CONVERSION_RATE,
                        severity=rule.severity,
                        title=f"Low Conversion Rate: {entity_name}",
                        message=f"Conversion rate is {pct_str}, below threshold of {rule.threshold * 100:.1f}%",
                        metric_name="conversion_rate",
                        metric_value=conversion_rate,
                        threshold=rule.threshold,
                        platform=platform,
                        entity_type=entity_type,
                        entity_id=entity_id,
                        entity_name=entity_name,
                        date=date,
                        metadata={"rule_name": rule.name},
                    )
                )
                break

        return alerts

    def evaluate_cancellation_rate(
        self,
        cancellation_rate: float | None,
        platform: str,
        entity_type: str,
        entity_id: str,
        entity_name: str,
        date: datetime,
    ) -> list[Alert]:
        """Evaluate cancellation rate against rules.

        Args:
            cancellation_rate: Cancellation rate (e.g., 0.10 for 10%).
            platform: Platform.
            entity_type: Type of entity.
            entity_id: Entity ID.
            entity_name: Entity name.
            date: Date of the metric.

        Returns:
            List of alerts generated.
        """
        alerts = []
        if cancellation_rate is None:
            return alerts

        for rule in self.get_rules_by_type(AlertType.HIGH_CANCELLATION_RATE):
            if rule.platforms and platform not in rule.platforms:
                continue

            if rule.evaluate(cancellation_rate):
                pct_str = f"{cancellation_rate * 100:.1f}%"
                alerts.append(
                    Alert(
                        alert_id=self._generate_alert_id(),
                        alert_type=AlertType.HIGH_CANCELLATION_RATE,
                        severity=rule.severity,
                        title=f"High Cancellation Rate: {entity_name}",
                        message=f"Cancellation rate is {pct_str}, above threshold of {rule.threshold * 100:.1f}%",
                        metric_name="cancellation_rate",
                        metric_value=cancellation_rate,
                        threshold=rule.threshold,
                        platform=platform,
                        entity_type=entity_type,
                        entity_id=entity_id,
                        entity_name=entity_name,
                        date=date,
                        metadata={"rule_name": rule.name},
                    )
                )
                break

        return alerts

    def evaluate_all(
        self,
        metrics: dict[str, Any],
        platform: str,
        entity_type: str,
        entity_id: str,
        entity_name: str,
        date: datetime,
    ) -> list[Alert]:
        """Evaluate all available metrics against rules.

        Args:
            metrics: Dictionary of metric name -> value.
            platform: Platform.
            entity_type: Type of entity.
            entity_id: Entity ID.
            entity_name: Entity name.
            date: Date of the metric.

        Returns:
            List of all alerts generated.
        """
        alerts = []

        if "roas" in metrics:
            alerts.extend(
                self.evaluate_roas(
                    metrics["roas"], platform, entity_type, entity_id, entity_name, date
                )
            )

        if "cpa" in metrics:
            alerts.extend(
                self.evaluate_cpa(
                    metrics["cpa"], platform, entity_type, entity_id, entity_name, date
                )
            )

        if "revenue_change_pct" in metrics:
            alerts.extend(
                self.evaluate_revenue_change(
                    metrics["revenue_change_pct"],
                    platform,
                    entity_type,
                    entity_id,
                    entity_name,
                    date,
                    metrics.get("current_revenue"),
                    metrics.get("previous_revenue"),
                )
            )

        if "conversion_rate" in metrics:
            alerts.extend(
                self.evaluate_conversion_rate(
                    metrics["conversion_rate"],
                    platform,
                    entity_type,
                    entity_id,
                    entity_name,
                    date,
                )
            )

        if "cancellation_rate" in metrics:
            alerts.extend(
                self.evaluate_cancellation_rate(
                    metrics["cancellation_rate"],
                    platform,
                    entity_type,
                    entity_id,
                    entity_name,
                    date,
                )
            )

        return alerts
